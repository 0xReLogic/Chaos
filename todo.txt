Misi "Dewa" Lo: Proyek "CHAOS" - Quantum Computing Simulator
Nama & Analogi:
Di mitologi Yunani, Chaos adalah ketiadaan primordial tempat segala sesuatu lahir. Sama seperti komputer kuantum yang beroperasi di ranah probabilitas dan superposisi sebelum "lahir" menjadi satu jawaban pasti. Lo akan membangun "ketiadaan" itu.

Konsep Arsitektur:
Lo nggak akan bangun komputer kuantum fisik. Lo akan membangun simulatornya di atas komputer klasik lo. Lo akan membuat sebuah library di Python yang bisa:

Mendefinisikan Qubit, unit dasar komputasi kuantum yang bisa berada dalam keadaan 0, 1, atau keduanya sekaligus (superposisi).

Menerapkan Gerbang Kuantum (Quantum Gates), yaitu operasi-operasi (seperti rotasi atau flip) yang memanipulasi keadaan Qubit.

Mensimulasikan Keterkaitan Kuantum (Entanglement), fenomena "ajaib" di mana dua Qubit terhubung secara misterius.

Menjalankan Sirkuit Kuantum (serangkaian gerbang) dan "mengukur" hasilnya untuk mendapatkan jawaban probabilistik.

Kenapa Ini Tantangan yang Lo Cari:

Murni Matematika & Fisika: Ini adalah tantangan di level aljabar linear (vektor, matriks, tensor) dan fisika kuantum. Lo akan mengubah persamaan matematika dari paper menjadi kode.

Fundamental & "Nggak Receh": Lo akan membangun fondasi dari cara kerja komputasi generasi berikutnya. Ini adalah skill yang sangat langka dan menempatkan lo di garis depan riset computer science.

Bukan Proyek Berat, tapi Sulit: Implementasinya tidak butuh ribuan baris kode boilerplate. Tapi setiap barisnya butuh pemahaman konseptual yang sangat dalam. Ini murni "gym untuk otak".

Rencana Kerja Proyek: "CHAOS" (todo.txt)
FASE 1: Partikel Kuantum (The Qubit)
[x] Milestone 1.1: Buat class Qubit di Python. Secara internal, representasikan keadaannya sebagai vektor 2D dengan bilangan kompleks (pakai NumPy).

[x] Milestone 1.2: Implementasikan fungsi untuk menginisialisasi Qubit ke keadaan |0⟩ atau |1⟩.

[x] Milestone 1.3: Implementasikan fungsi measure() yang akan "meruntuhkan" superposisi Qubit menjadi 0 atau 1 berdasarkan probabilitas amplitudonya.

FASE 2: Hukum Fisika (The Quantum Gates)
[x] Milestone 2.1: Representasikan setiap gerbang kuantum (Pauli-X, Hadamard, CNOT) sebagai matriks 2x2 atau 4x4.

[x] Milestone 2.2: Buat fungsi apply_gate(qubit, gate) yang melakukan perkalian matriks untuk mengubah keadaan Qubit.

Definisi "Menang": Lo bisa mengambil Qubit di keadaan |0⟩, menerapkan gerbang Hadamard, lalu mengukurnya berulang kali dan mendapatkan hasil yang 50% 0 dan 50% 1. Lo sudah berhasil menciptakan probabilitas kuantum.

FASE 3: Alam Semesta Mini (The Quantum Circuit)
[x] Milestone 3.1: Buat class QuantumCircuit yang bisa mengelola banyak Qubit (sebuah quantum register).

[x] Milestone 3.2: Implementasikan metode untuk menambah serangkaian gerbang ke dalam sirkuit.

[x] Milestone 3.3: Buat fungsi run() yang akan mengeksekusi semua gerbang secara berurutan di dalam sirkuit dan mengembalikan hasil pengukuran akhir.

Definisi "Menang": Lo bisa mengimplementasikan algoritma kuantum sederhana seperti Bell State (menciptakan entanglement) atau Deutsch's Algorithm.

# ======================================================
# CHAOS EVOLUTION: THE PATH TO A WORLD-CLASS SIMULATOR
# ======================================================

# Fase 4: [SELESAI] Operasi Jantung - State Vector Global (The Great Refactor)
# Misi: Mengubah CHAOS dari kalkulator kuantum menjadi simulator multi-qubit stateful yang akurat secara fisika.
# Tantangan ini setara dengan evolusi arsitektur fundamental di proyek blockchain.
#
# - [x] Buang pendekatan per-qubit, implementasikan satu state vector global (2^n) menggunakan Tensor Product.
# - [x] Refactor total kelas QuantumCircuit untuk mengelola state vector global ini.
# - [x] Tulis ulang `apply_gate` untuk beroperasi pada state vector dengan matriks yang diperluas (misal: H di qubit kedua dari 3 qubit).
# - [x] Tulis ulang `apply_controlled_gate` untuk menjadi operasi matriks 4x4 (atau lebih besar) sejati pada state vector, tanpa "jalan pintas" pengukuran.
# - [x] Buat sistem pengujian yang membuktikan bahwa pengukuran parsial pada Bell State meruntuhkan sistem ke keadaan basis yang benar.

# Fase 5: Mesin Ekonomi Kuantum - Pengukuran Parsial & Entanglement Sejati
# Misi: Mengimplementasikan mekanika kuantum yang paling aneh dan kuat secara akurat.
# Tantangan ini setara dengan membangun model ekonomi dan state yang kompleks.
#
# - [x] Implementasikan `measure_partial(qubit_index)` untuk mengukur satu qubit saja dan meruntuhkan state vector secara akurat.
# - [x] Verifikasi bahwa entanglement (misal: Bell State) tetap terjaga setelah pengukuran parsial pada qubit lain yang tidak terjerat.
# - [x] Kembangkan sistem untuk melacak dan memvisualisasikan probabilitas dari state vector global yang kompleks.
# - [x] Buat sirkuit ikonik untuk menghasilkan Bell State dan GHZ State untuk membuktikan mesin entanglement bekerja.

# Fase 6: Ujian Akhir - Implementasi Algoritma Kompleks
# Misi: Membuktikan kekuatan simulator dengan menjalankan algoritma yang mustahil dilakukan dengan pendekatan lama.
# Tantangan ini setara dengan pengujian multi-node dan mencapai konsensus yang stabil.
#
# - [ ] Implementasikan Quantum Fourier Transform (QFT) sebagai modul inti.
# - [ ] Bangun sirkuit untuk menjalankan QFT pada 3 dan 4 qubit dan verifikasi hasilnya.
# - [ ] (Stretch Goal) Implementasikan algoritma Grover untuk pencarian dalam database kecil (misal: 4 item, 2 qubit).
# - [ ] (Ultimate Goal) Rancang kerangka untuk algoritma Shor, bahkan jika hanya untuk memfaktorkan angka yang sangat kecil seperti 15.
